
import { serve } from "https://deno.land/std@0.168.0/http/server.ts";
import { corsHeaders, handleCORS, checkRateLimit } from './cors.ts';
import { validateEnvironment, validateRequest } from './validation.ts';
import { authenticateUser } from './auth.ts';
import { savePodcastToDatabase } from './database.ts';

// Security headers
const securityHeaders = {
  'X-Content-Type-Options': 'nosniff',
  'X-Frame-Options': 'DENY',
  'X-XSS-Protection': '1; mode=block',
  'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',
  'Content-Security-Policy': "default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; connect-src 'self' https:;",
};

serve(async (req: Request) => {
  const corsResponse = handleCORS(req);
  if (corsResponse) return corsResponse;

  try {
    console.log('=== Generate podcast function called ===');
    console.log('Request method:', req.method);
    console.log('Request headers:', Object.fromEntries(req.headers.entries()));
    
    // Rate limiting check
    const clientIp = req.headers.get('x-forwarded-for') || req.headers.get('x-real-ip') || 'unknown';
    if (!checkRateLimit(clientIp, 5, 60000)) {
      console.log('Rate limit exceeded for client:', clientIp);
      return new Response(JSON.stringify({ 
        error: 'Rate limit exceeded',
        details: 'Too many requests. Please try again later.'
      }), {
        status: 429,
        headers: { ...corsHeaders, ...securityHeaders, 'Content-Type': 'application/json' },
      });
    }

    // Validate environment
    const envError = validateEnvironment();
    if (envError) {
      console.error('Environment validation failed:', envError);
      return new Response(JSON.stringify({ 
        error: envError,
        details: 'Please check your Supabase secrets configuration'
      }), {
        status: 500,
        headers: { ...corsHeaders, ...securityHeaders, 'Content-Type': 'application/json' },
      });
    }

    // Parse and validate request body
    let body;
    try {
      body = await req.json();
      console.log('Request body parsed successfully:', {
        title: body.title,
        package_type: body.package_type,
        voice_clone: body.voice_clone,
        premium_assets: body.premium_assets,
        source_type: body.source_type,
        linkedin_url: body.linkedin_url || 'Not provided',
        resume_content_length: body.resume_content?.length || 0
      });
    } catch (parseError) {
      console.error('Failed to parse request body:', parseError);
      return new Response(JSON.stringify({ 
        error: 'Invalid JSON in request body',
        details: parseError.message 
      }), {
        status: 400,
        headers: { ...corsHeaders, ...securityHeaders, 'Content-Type': 'application/json' },
      });
    }

    const validation = validateRequest(body);
    if (!validation.isValid) {
      console.error('Request validation failed:', validation.error);
      return new Response(JSON.stringify({ 
        error: validation.error,
        details: 'Request validation failed'
      }), {
        status: 400,
        headers: { ...corsHeaders, ...securityHeaders, 'Content-Type': 'application/json' },
      });
    }

    // Authenticate user
    let user;
    try {
      console.log('Authenticating user...');
      user = await authenticateUser(req);
      console.log('User authenticated successfully:', user.id);
    } catch (authError) {
      console.error('Authentication failed:', authError);
      return new Response(JSON.stringify({ 
        error: authError.message,
        details: 'User authentication failed'
      }), {
        status: 401,
        headers: { ...corsHeaders, ...securityHeaders, 'Content-Type': 'application/json' },
      });
    }

    // For LinkedIn URLs, create placeholder transcript since Zapier MCP will handle everything
    let generatedScript = 'Placeholder transcript - will be generated by Zapier MCP workflow using Claude integration.';
    
    if (validation.data!.source_type === 'linkedin_url') {
      console.log('LinkedIn URL detected - transcript will be generated by Zapier MCP');
      generatedScript = `LinkedIn Profile Podcast: ${validation.data!.title}

This podcast transcript will be generated by our Zapier MCP workflow using Claude integration.

LinkedIn Profile: ${validation.data!.linkedin_url}

The workflow will:
1. Extract comprehensive profile data from LinkedIn
2. Generate a professional podcast script using Claude
3. Process the content for optimal audio production
4. Return the final transcript and audio

Status: Processing via Zapier MCP workflow...`;
    } else {
      console.log('Resume content provided - will still route through Zapier MCP for consistency');
      generatedScript = `Resume-based Podcast: ${validation.data!.title}

This podcast transcript will be generated by our Zapier MCP workflow using Claude integration.

The workflow will process the provided resume content and generate a professional podcast script.

Status: Processing via Zapier MCP workflow...`;
    }

    // Save to database - the database function will trigger Zapier MCP
    let podcastData;
    try {
      console.log('Saving podcast to database and triggering Zapier MCP workflow...');
      podcastData = await savePodcastToDatabase(user, validation.data!, generatedScript);
      console.log('Podcast saved successfully with ID:', podcastData.id);
      console.log('Zapier MCP workflow triggered for complete processing');
    } catch (dbError) {
      console.error('Database save failed:', dbError);
      console.error('Database error stack:', dbError.stack);
      
      return new Response(JSON.stringify({ 
        error: dbError.message,
        details: 'Failed to save podcast to database',
        errorType: dbError.constructor.name
      }), {
        status: 500,
        headers: { ...corsHeaders, ...securityHeaders, 'Content-Type': 'application/json' },
      });
    }

    console.log('Function completed successfully - Zapier MCP will handle transcript and audio generation');
    return new Response(JSON.stringify({ podcast: podcastData }), {
      headers: { ...corsHeaders, ...securityHeaders, 'Content-Type': 'application/json' },
      status: 200,
    });

  } catch (error) {
    console.error('=== CRITICAL ERROR in generate-podcast function ===');
    console.error('Error type:', error.constructor.name);
    console.error('Error message:', error.message);
    console.error('Error stack:', error.stack);
    console.error('Error details:', error);
    
    return new Response(JSON.stringify({ 
      error: `Internal server error: ${error.message}`,
      details: 'Check function logs for more information',
      errorType: error.constructor.name,
      stack: error.stack
    }), {
      headers: { ...corsHeaders, ...securityHeaders, 'Content-Type': 'application/json' },
      status: 500,
    });
  }
});
